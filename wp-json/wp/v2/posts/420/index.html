{"id":420,"date":"2023-08-03T07:09:04","date_gmt":"2023-08-03T07:09:04","guid":{"rendered":"http:\/\/192.168.0.142\/?p=420"},"modified":"2023-08-03T07:10:24","modified_gmt":"2023-08-03T07:10:24","slug":"singleton-design-pattern-in-c","status":"publish","type":"post","link":"http:\/\/192.168.0.142\/singleton-design-pattern-in-c\/","title":{"rendered":"Singleton Design Pattern in C#"},"content":{"rendered":"\n<ul>\n<li>Only one instance of object is created.<\/li>\n\n\n\n<li>Is a creational design pattern which makes sure that you have one single instance of a particular class in the duration of your runtime, and provides a global point of access to the single instance.<\/li>\n<\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"csharp\" class=\"language-csharp\">public class Singleton\r\n    {\r\n        private static Singleton instance;\r\n\r\n        private Singleton() { }\r\n\r\n        public static Singleton Instance\r\n        {\r\n            get\r\n            {\r\n                if (instance == null)\r\n                {\r\n                    instance = new Singleton();\r\n                }\r\n                return instance;\r\n            }\r\n        }\r\n    }\r\n<\/code><\/pre>\n\n\n\n<ul>\n<li>The main disadvantage of this implementation is that it is not safe for multithreaded environments. If separate threads of execution enter the Instance property method at the same time, more than one instance of the Singleton object may be created.<\/li>\n<\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code class=\"\">\r\npublic sealed class Singleton\r\n    {\r\n        private static volatile Singleton instance;\r\n        private static object syncRoot = new Object();\r\n\r\n        private Singleton() { }\r\n\r\n        public static Singleton Instance\r\n        {\r\n            get\r\n            {\r\n                if (instance == null)\r\n                {\r\n                    lock (syncRoot)\r\n                    {\r\n                        if (instance == null)\r\n                            instance = new Singleton();\r\n                    }\r\n                }\r\n\r\n                return instance;\r\n            }\r\n        }\r\n    }\r\n<\/code><\/pre>\n\n\n\n<ul>\n<li>The above approach ensures that only one instance is created and only when the instance is needed.<\/li>\n\n\n\n<li>Also variable is declared to be volatile to ensure that assignment to the instance variable completes before the instance variable can be accessed. Lastly this approach uses a syncRoot instance to lock on, rather than locking on the type itself, to avoid deadlocks<\/li>\n<\/ul>\n","protected":false},"excerpt":{"rendered":"","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[32],"tags":[33,39],"_links":{"self":[{"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/posts\/420"}],"collection":[{"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/comments?post=420"}],"version-history":[{"count":4,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/posts\/420\/revisions"}],"predecessor-version":[{"id":424,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/posts\/420\/revisions\/424"}],"wp:attachment":[{"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/media?parent=420"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/categories?post=420"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/192.168.0.142\/wp-json\/wp\/v2\/tags?post=420"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}